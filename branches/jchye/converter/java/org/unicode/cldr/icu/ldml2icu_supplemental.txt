# Used by SupplementalMapper.
# Data-driven file for mapping supplemental LDML paths to ICU paths.
# Order is not important, so regexes are grouped logically and are assumed to be
# mutually exclusive.
# The format is:
#   ldmlRegex ; icuPath (; specialInstructions)*
#
# If an LDML xpath results in two or more ICU paths, they should be split into
# multiple lines, like this:
#   ldmlRegex
#       ; icuPath1 (; specialInstructions)*
#       ; icuPath2 (; specialInstructions)*
#       ...
#
# Each regex pattern must match an xpath completely to have a successful match.
# Square brackets that are part of the xpath will be preceded by a backslash
# during processing, so there's no need to do it here.
# specialInstructions are optional. There may be multiple special instructions,
# with each instruction being one of the following:
#     - values=<comma-separated-values> which can be
#       - hardcoded strings,
#       - regex arguments w.r.t the xpath regex (e.g. $1) or
#       - {value} to represent the value of the xpath in the CLDR data
#     - fallback=<value> which can be
#       - a hardcoded string or
#       - a regex argument that is already in the rbPath
#     - group, which indicates that the values created using this xpath should
#       be grouped together in their own sub-array in the ICU data file. This
#       instruction should be used instead of hidden labels if the
#       array is in an array of values, e.g.
#       DateTimePatterns {
#            "HH:mm",
#            {
#                "EEEE, d ×‘MMMM y",
#                "hebr",
#            }
#            ...
# All matched arguments from xpaths will be split by whitespace unless the
# corresponding argument in the replacement string is surrounded by quotes, e.g.
# "$1".
#
# Some ICU paths will contain hidden labels which are enclosed in angle brackets,
# e.g. /telephoneCodeData/$1/<$2>/code. They are processed and sorted like any
# any other ICU path, except that labels enclosed in angle brackets will not be
# written to the ICU file. This is used to create arrays without labels where
# necessary, e.g. the example ICU path would result in the following output:
#    telephoneCodeData{
#        001{
#            {
#                code{"388"}
#            }
#            {
#                code{"800"}
#            }
#            ...
#
# <FIFO> is a special case: using this label will cause the values from a single
# xpath to be grouped together in the same array, and the arrays will be written
# in the same order that they were read from the CLDR file.

# Variables
# The following variables are substituted into all the regexes in this file.
# Attribute value
%A=[^"']++
# Word/Zone match
%W=[\s\w\-/]++
# Greedy word match
%G=[\s\w\-]+
# Number match
%N=\d++

# supplementalData.xml
# TODO: some values are sorted in supplementalData. Is this actually needed?
//supplementalData/currencyData/region[@iso3166="(%W)"]/currency[@iso4217="(%W)"]([@tender="false"])?
     ; /CurrencyMap/$1/<FIFO>/id ; values=$2
     ; /CurrencyMap/$1/<FIFO>/from:intvector ; values=9999-12-31
//supplementalData/currencyData/region[@iso3166="(%W)"]/currency[@from="(%W)"][@iso4217="(%W)"]
     ; /CurrencyMap/$1/<FIFO>/id ; values=$3
     ; /CurrencyMap/$1/<FIFO>/from:intvector ; values=$2
//supplementalData/currencyData/region[@iso3166="(%W)"]/currency[@from="(%W)"][@to="(%W)"][@iso4217="(%W)"]
     ; /CurrencyMap/$1/<FIFO>/id ; values=$4
     ; /CurrencyMap/$1/<FIFO>/from:intvector ; values=$2
     ; /CurrencyMap/$1/<FIFO>/to:intvector ; values=$3

//supplementalData/currencyData/fractions/info[@iso4217="(%W)"][@digits="(%N)"][@rounding="(%N)"] ; /CurrencyMeta/$1:intvector ; values=$2 $3

//supplementalData/calendarPreferenceData/calendarPreference[@territories="(%A)"][@ordering="(%A)"] ; /calendarPreferenceData/$1    ; values=$2
//supplementalData/codeMappings/territoryCodes[@type="(%W)"][@numeric="(%N)"][@alpha3="(%W)"].* ; /codeMappings/<$1> ; values=$1 $2 $3

//supplementalData/languageData/language[@type="(%W)"][@scripts="(%W)"] ; /languageData/$1/primary/scripts ; values=$2
//supplementalData/languageData/language[@type="(%W)"][@scripts="(%W)"][@territories="(%W)"]
     ; /languageData/$1/primary/scripts ; values=$2
     ; /languageData/$1/primary/territories; values=$3
//supplementalData/languageData/language[@type="(%W)"][@territories="(%W)"] ; /languageData/$1/primary/territories ; values=$2

//supplementalData/languageData/language[@type="(%W)"][@scripts="(%W)"][@alt="secondary"] ; /languageData/$1/secondary/scripts ; values=$2
//supplementalData/languageData/language[@type="(%W)"][@territories="(%G)"][@alt="secondary"] ; /languageData/$1/secondary/territories ; values=$2
//supplementalData/languageData/language[@type="(%W)"][@scripts="(%W)"][@territories="(%W)"][@alt="secondary"]
     ; /languageData/$1/secondary/scripts ; values=$2
     ; /languageData/$1/secondary/territories ; values=$3

# TODO: check if these need to be sorted.
//supplementalData/territoryContainment/group[@type="(%W)"][@contains="(%A)"]; /territoryContainment/$1 ; values=$2
//supplementalData/territoryContainment/group[@type="(%W)"][@contains="(%A)"][@grouping="true"]
     ; /territoryContainment/$1 ; values=$2
     ; /territoryContainment/grouping ; values=$1

//supplementalData/weekData/minDays[@count="(%N)"][@territories="(%W)"] ; /weekData/$2:intvector    ; values=$1 ; fallback=1
//supplementalData/weekData/firstDay[@day="(%W)"][@territories="(%W)"] ; /weekData/$2:intvector     ; values=$1
//supplementalData/weekData/weekendStart[@day="(%W)"][@territories="(%W)"] ; /weekData/$2:intvector     ; values=$1 0 ; fallback=7 0
//supplementalData/weekData/weekendEnd[@day="(%W)"][@territories="(%W)"] ; /weekData/$2:intvector     ; values=$1 86400000 ; fallback=1 86400000

# telephoneCodeData.xml
//supplementalData/telephoneCodeData/codesByTerritory[@territory="(%W)"]/telephoneCountryCode[@code="(%N)"] ; /telephoneCodeData/$1/<$2>/code ; values=$2
//supplementalData/telephoneCodeData/codesByTerritory[@territory="(%W)"]/telephoneCountryCode[@code="(%N)"][@alt="(%W)"]
     ; /telephoneCodeData/$1/<$2>/code ; values=$2
     ; /telephoneCodeData/$1/<$2>/alt ; values=$3

# languageInfo.xml
#TODO: what to do about extra values?
//supplementalData/languageMatching/languageMatches[@type="(%A)"]/languageMatch[@_q="%N"][@desired="(%A)"](?:[@oneway="true"])?[@percent="(%N)"][@supported="(%A)"] ; /languageMatching/$1/<$2$4> ; values=$2 $4 $3

# likelySubtags.xml
//supplementalData/likelySubtags/likelySubtag[@from="(%A)"][@to="(%A)"] ; /$1 ; values=$2

# supplementalMetadata.xml
//supplementalData/metadata/alias/(language|script|territory|variant)Alias[@type="(%A)"][@replacement="(%A)"][@reason="%A"] ; /$1Alias/$2 ; values="$3"
# Specify the value explicitly so that the LDMLConverter will split it.
//supplementalData/metadata/validity/variable[@_q="%N"][@type="choice"][@id="\$territory"] ; /regionCodes ; values={value}

# metaZones.xml - metaZones.txt
//supplementalData/metaZones/mapTimezones[@type="metazones"][@typeVersion="%A"]/mapZone[@type="(%A)"][@other="(%W)"][@territory="(%W)"] ; /mapTimezones/$2/$3 ; values=$1
//supplementalData/metaZones/metazoneInfo/timezone[@type="(%W)"]/usesMetazone[@mzone="(%W)"] ; /metazoneInfo/"$1"/<$2> ; values=$2
//supplementalData/metaZones/metazoneInfo/timezone[@type="(%W)"]/usesMetazone[@from="(%A)"][@mzone="(%W)"] ; /metazoneInfo/"$1"/<$2> ; values=$3 "$2" "9999-12-31 23:59"
//supplementalData/metaZones/metazoneInfo/timezone[@type="(%W)"]/usesMetazone[@from="(%A)"][@to="(%A)"][@mzone="(%W)"] ; /metazoneInfo/"$1"/<$2> ; values=$4 "$2" "$3"
//supplementalData/metaZones/metazoneInfo/timezone[@type="(%W)"]/usesMetazone[@to="(%A)"][@mzone="(%W)"] ; /metazoneInfo/"$1"/<1970-01-01 00:00> ; values=$3 "1970-01-01 00:00" "$2"

# numberingSystems.txt
//supplementalData/numberingSystems/numberingSystem[@type="algorithmic"][@id="(%W)"][@rules="(%A)"]
     ; /numberingSystems/$1/algorithmic:int ; values=1
     ; /numberingSystems/$1/desc ; values=$2
     ; /numberingSystems/$1/radix:int ; values=10

//supplementalData/numberingSystems/numberingSystem[@type="numeric"][@id="(%W)"][@digits="(%A)"]
     ; /numberingSystems/$1/algorithmic:int ; values=0
     ; /numberingSystems/$1/desc ; values=$2
     ; /numberingSystems/$1/radix:int ; values=10

# windowsZones.txt
//supplementalData/windowsZones/mapTimezones[@otherVersion="%W"][@typeVersion="%W"]/mapZone[@type="(%A)"][@other="(%A)"][@territory="(001)"] ; /mapTimezones/"$2"/$3 ; values=$1
