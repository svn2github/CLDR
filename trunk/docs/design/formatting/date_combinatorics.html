<html>

<head>
<meta http-equiv="Content-Language" content="en-us">
<meta name="GENERATOR" content="Microsoft FrontPage 5.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<title>Avoiding the Date Combinatoric Explosion</title>
</head>

<body>

<h1>Avoiding the Date Combinatoric Explosion</h1>
<h2><font color="#FF0000"><span style="background-color: #FFFF00">Very, Very Rough Draft</span></font></h2>
<p><b>2004-10-5 MED</b></p>
<p>Many different applications need different combinations of date fields, such as just month and 
year. If we try to handle all of these, the combinations are overwhelming, both for us and the 
localizers. Here are some ideas for handling that.</p>
<p>The goal is to be able to provide a localized string given any input set of fields. The input is 
a string containing any of of the date field characters: GyMdhmsEDFwWzA, with varying numbers. E.g. 
&quot;MMyyyy&quot;. The input must be in a canonical order, which is (say) code point order.</p>
<p>The output would be a synthesized date format string. The result would be cached, so the 
synthesis process can spend a reasonable, though not inordinate, amount of time to figure out the 
best fit.</p>
<p>Each alternative approach would require different types of data in to be added to CLDR. I'm not 
getting into the syntax of what that data would look like yet, until we explore some of the 
alternatives.</p>
<p>Examples from English:</p>
<p>CLDR</p>
<table width="100%" border="2">
  <tr>
    <td>Full Time</td>
    <td>h:mm:ss a z </td>
  </tr>
  <tr>
    <td>Long Time</td>
    <td>h:mm:ss a z </td>
  </tr>
  <tr>
    <td>Medium Time</td>
    <td>h:mm:ss a </td>
  </tr>
  <tr>
    <td>Short Time</td>
    <td>h:mm a </td>
  </tr>
  <tr>
    <td>Full Date</td>
    <td>EEEE, MMMM d, yyyy </td>
  </tr>
  <tr>
    <td>Long Date</td>
    <td>MMMM d, yyyy </td>
  </tr>
  <tr>
    <td>Medium Date</td>
    <td>MMM d, yyyy </td>
  </tr>
  <tr>
    <td>Short Date</td>
    <td>M/d/yy </td>
  </tr>
  <tr>
    <td>Date-Time pattern.<br>
    {0} = time, {1} = date</td>
    <td>{1} {0} </td>
  </tr>
</table>
<p>Open Office:</p>
<ul>
  <li>MMM D, YY</li>
  <li>MMM D, YYYY</li>
  <li>NN, MMMM D, YYYY</li>
  <li>YY-MM-DD</li>
  <li>...</li>
</ul>
<p>See</p>
<ul>
  <li><a href="http://oss.software.ibm.com/cvs/icu/~checkout~/locale/diff/main//en_US.html">
  http://oss.software.ibm.com/cvs/icu/~checkout~/locale/diff/main//en_US.html</a></li>
  <li><a href="http://oss.software.ibm.com/cgi-bin/icu/lx/?d_=en_US&_=en_US">
  http://oss.software.ibm.com/cgi-bin/icu/lx/?d_=en_US&amp;_=en_US</a></li>
</ul>
<h2>Alternative 1.</h2>
<p>1. Match to patterns in locale data. Pick best match, where for each field difference we charge a 
penalty. Here are some initial values: we could try tuning for best results.<br>
<br>
-1000 if field missing in pattern<br>
-100 if extra field in pattern<br>
-10 if &quot;big&quot; change (e.g. text to number or vice versa)<br>
-1 if small change (zero padding or not, full vs. abbr text)<br>
<br>
H,K,k are treated as &quot;big change&quot; variants of h, so they would be absent from the input, as would be 
'a'.</p>
<p>2. Remove fields, and fix non-field characters.<br>
<br>
Walk through string from front to back, removing fields that don't match key.<br>
<br>
For the non-field characters between fields:<br>
- delete entirely if both neighboring fields are deleted<br>
- delete entirely if leading and first field is deleted<br>
- delete entirely if trailing and last field is deleted<br>
- delete &quot;partially&quot; if one adjacent field is deleted and the other isn't<br>
- if non-field characters doesn't contain &#9474;, act as if there is a &#9474; at the end.<br>
- delete up to &#9474; (on the side of the deleted field)<br>
Example: removing m:<br>
yyyy:mm.dd =&gt; yyyy:dd<br>
yyyy&#9474;:mm&#9474;.dd =&gt; yyyy.dd<br>
yyyy_:_mm |. dd =&gt; yyyy_:_ dd<br>
<br>
Also:<br>
- 'a' (am/pm) is removed if h or K is to be converted to H or k. E.g. &quot;hh:mm:ss&#9474; a&quot; =&gt; &quot;HH:mm:ss&quot;<br>
[Don't know if we can do this successfully; have to try it out.]<br>
<br>
- if S (fractional secs) is removed, and it is right after s, (secs) then<br>
non-field characters are removed. E.g. &quot;ss,SSSS&quot; =&gt; &quot;ss&quot;<br>
<br>
- Remove all &#9474;, once everything else is done.<br>
<br>
3. Change formats to match widths<br>
<br>
e.g. key = yyMMdd, best pattern from steps #1 &amp; #2 is &quot;yyyy MMM, d&quot;, then change widths to match 
key: &quot;yy MM, dd&quot;</p>
<p>Issues: </p>
<ol>
  <li>Requires additional syntax ('|'). </li>
  <li>May also want a syntax that allows us to say that certain characters 'hang' with both fields 
  on either side. Eg, yyyy_{;}_MMM, which says that you get yyyy_; if MMM is not present, and ;_MMM 
  if yyyy is not present. So }{ is the equivalent of | above.</li>
  <li>May not work well when fields are deleted from the middle.</li>
</ol>
<h3>Alternative 2.</h3>
<p>Most dates in most languages will only have certain combinations of fields next to one another. 
If we assume that intervening characters are only dependent on the format of those fields, we can 
have an approach like the following, which goes bottom up:</p>
<p>1. Find the order, using a list of strings.</p>
<ul>
  <li>EMdyhms</li>
  <li>EMdyhms</li>
</ul>
<p>2. Get intervening characters This takes the form of a list of pairs, with intervening 
characters. The list is searched in order. E.g.</p>
<ul>
  <li>h:m</li>
  <li>m:s</li>
  <li>s a</li>
  <li>MMM d</li>
  <li>M/d</li>
  <li>d/yy</li>
  <li>d, yyyy</li>
  <li>EEEE, MMMM</li>
</ul>
<p>As in Alternative 1, we use a best fit with some heuristic among the different options. Maybe we 
use regular expressions, so we can have something like</p>
<ul>
  <li>(EEEE | M+ | y+ | d+); (h+ | m+ | d+)</li>
</ul>
<p>In that case, it might be easier to separate into three fields, eg,</p>
<p>&lt;previous&gt;(EEEE | M+ | y+ | d+)&lt;/previous&gt;&lt;post&gt;(h+ | m+ | d+)&lt;/post&gt;&lt;filler&gt;; &lt;filler&gt;</p>
<p>Ref.</p>
<p><a href="http://oss.software.ibm.com/cvs/icu/~checkout~/locale/diff/main//en_US.html">
http://oss.software.ibm.com/cvs/icu/~checkout~/locale/diff/main//en_US.html</a> </p>

</body>

</html>
