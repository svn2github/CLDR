package org.unicode.cldr.draft;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import org.unicode.cldr.util.CLDRConfig;
import org.unicode.cldr.util.SupplementalDataInfo;

import com.google.common.base.Predicate;
import com.google.common.base.Splitter;
import com.ibm.icu.impl.Row;
import com.ibm.icu.impl.Row.R4;
import com.ibm.icu.util.LocaleMatcher;
import com.ibm.icu.util.Output;
import com.ibm.icu.util.ULocale;

public class XLocaleMatcher {

    LocaleDistance langDistance;

    private static class Id<T> {
        private Map<T,Integer> stringToId = new HashMap<>();
        private List<T> idToString = new ArrayList<>();
        public int add(T source) {
            Integer result = stringToId.get(source);
            if (result == null) {
                final int newResult = idToString.size();
                stringToId.put(source, newResult);
                idToString.add(source);
                return newResult;
            } else {
                return result;
            }
        }
        public Integer from(T source) {
            return stringToId.get(source); 
        }
        public T to(int id) {
            return idToString.get(id); 
        }
    }

    private static class DistanceNode {
        int distance;
        DistanceTable distanceTable;

        DistanceNode(int distance) {
            this.distance = distance;
        }

        public void addSubtables(String desiredSub, String supportedSub, Reset r) {
            if (distanceTable == null) {
                distanceTable = new DistanceTable();
            }
            distanceTable.addSubtables(desiredSub, supportedSub, r);
        }
        @Override
        public String toString() {
            return "distance: " + distance + "\n" + distanceTable;
        }

        public void copyTables(DistanceNode value) {
            if (value.distanceTable != null) {
                distanceTable = new DistanceTable();
                distanceTable.copy(value.distanceTable);
            }
        }
    }

    private static Map newMap() {
        return new LinkedHashMap();
    }

    private static class DistanceTable {
        final Map<String, Map<String, DistanceNode>> subtables = newMap();

        int getDistance(String desired, String supported, Output<DistanceNode> distanceTable) {
            boolean star = false;
            Map<String, DistanceNode> sub2 = subtables.get(desired);
            if (sub2 == null) {
                sub2 = subtables.get("*"); // <*, supported>
                star = true;
            }
            DistanceNode value = sub2.get(supported);   // <*/desired, supported>
            if (value == null) {
                value = sub2.get("*");  // <*/desired, *>
                if (value == null && !star) {
                    sub2 = subtables.get("*");   // <*, supported>
                    value = sub2.get(supported);
                    if (value == null) {
                        value = sub2.get("*");   // <*, *>
                    }
                }
                star = true;
            }
            distanceTable.value = value;
            return star & desired.equals(supported) ? 0 : value.distance;
        }

        public void copy(DistanceTable other) {
            for (Entry<String, Map<String, DistanceNode>> e1 : other.subtables.entrySet()) {
                for (Entry<String, DistanceNode> e2 : e1.getValue().entrySet()) {
                    DistanceNode value = e2.getValue();
                    DistanceNode subNode = addSubtable(e1.getKey(), e2.getKey(), value.distance, false);
                }
            }
        }

        DistanceNode addSubtable(String desired, String supported, int distance, boolean skipIfSet) {
            Map<String, DistanceNode> sub2 = subtables.get(desired);
            if (sub2 == null) {
                subtables.put(desired, sub2 = newMap());
            }
            DistanceNode oldNode = sub2.get(supported);
            if (oldNode != null) {
                if (oldNode.distance == distance || skipIfSet) {
                    return oldNode;
                } else {
                    throw new IllegalArgumentException("Overriding values for " + desired + ", " + supported
                        + ", old distance: " + oldNode.distance + ", new distance: " + distance);
                }
            }

            final DistanceNode newNode = new DistanceNode(distance);
            sub2.put(supported, newNode);
            return newNode;
        }

        private DistanceNode getNode(String desired, String supported) {
            Map<String, DistanceNode> sub2 = subtables.get(desired);
            if (sub2 == null) {
                return null;
            }
            return sub2.get(supported);
        }


        /** add table for each subitem that matches and doesn't have a table already
         */
        public void addSubtables(
            String desired, String supported, 
            Predicate<DistanceNode> action) {
            int count = 0;
            DistanceNode node = getNode(desired, supported);
            if (node == null) {
                // get the distance it would have
                Output<DistanceNode> node2 = new Output<>();
                int distance = getDistance(desired, supported, node2);
                // now add it
                node = addSubtable(desired, supported, distance, true);
                if (node2.value != null) {
                    node.copyTables(node2.value);
                }
            }
            action.apply(node);
        }

        public void addSubtables(String desiredLang, String supportedLang, 
            String desiredScript, String supportedScript, 
            int percentage) {

            // add to all the values that have the matching desiredLang and supportedLang
            boolean haveKeys = false;
            for (Entry<String, Map<String, DistanceNode>> e1 : subtables.entrySet()) {
                String key1 = e1.getKey();
                final boolean desiredIsKey = desiredLang.equals(key1);
                if (desiredIsKey || desiredLang.equals("*")) {
                    for (Entry<String, DistanceNode> e2 : e1.getValue().entrySet()) {
                        String key2 = e2.getKey();
                        final boolean supportedIsKey = supportedLang.equals(key2);
                        haveKeys |= (desiredIsKey && supportedIsKey);
                        if (supportedIsKey || supportedLang.equals("*")) {
                            DistanceNode value = e2.getValue();
                            if (value.distanceTable == null) {
                                value.distanceTable = new DistanceTable();
                            }
                            value.distanceTable.addSubtable(desiredScript, supportedScript, percentage, true);
                        }
                    }
                }
            }
            // now add the sequence explicitly
            DistanceTable dt = new DistanceTable();
            dt.addSubtable(desiredScript, supportedScript, percentage, false);
            Reset r = new Reset(dt);
            addSubtables(desiredLang, supportedLang, r);
        }

        public void addSubtables(String desiredLang, String supportedLang, 
            String desiredScript, String supportedScript, 
            String desiredRegion, String supportedRegion, 
            int percentage) {
            
            // add to all the values that have the matching desiredLang and supportedLang
            boolean haveKeys = false;
            for (Entry<String, Map<String, DistanceNode>> e1 : subtables.entrySet()) {
                String key1 = e1.getKey();
                final boolean desiredIsKey = desiredLang.equals(key1);
                if (desiredIsKey || desiredLang.equals("*")) {
                    for (Entry<String, DistanceNode> e2 : e1.getValue().entrySet()) {
                        String key2 = e2.getKey();
                        final boolean supportedIsKey = supportedLang.equals(key2);
                        haveKeys |= (desiredIsKey && supportedIsKey);
                        if (supportedIsKey || supportedLang.equals("*")) {
                            DistanceNode value = e2.getValue();
                            if (value.distanceTable == null) {
                                value.distanceTable = new DistanceTable();
                            }
                            value.distanceTable.addSubtables(desiredScript, supportedScript, desiredRegion, supportedRegion, percentage);
                        }
                    }
                }
            }
            // now add the sequence explicitly
            
            DistanceTable dt = new DistanceTable();
            dt.addSubtable(desiredRegion, supportedRegion, percentage, false);
            AddSub r = new AddSub(desiredScript, supportedScript, dt);
            addSubtables(desiredLang,  supportedLang,  r);  
        }

        @Override
        public String toString() {
            return toString("", new StringBuilder()).toString();
        }

        public StringBuilder toString(String indent, StringBuilder buffer) {
            for (Entry<String, Map<String, DistanceNode>> e1 : subtables.entrySet()) {
                for (Entry<String, DistanceNode> e2 : e1.getValue().entrySet()) {
                    DistanceNode value = e2.getValue();
                    buffer.append("\n" + indent + "\t<" + e1.getKey() + ", " + e2.getKey() + "> => " + value.distance);
                    if (value.distanceTable != null) {
                        value.distanceTable.toString(indent+"\t", buffer);
                    }
                }
            }
            return buffer;
        }
    }

    static class Reset implements Predicate<DistanceNode> {
        private final DistanceTable resetIfNotNull;
        Reset(DistanceTable resetIfNotNull) {
            this.resetIfNotNull = resetIfNotNull;
        }
        @Override
        public boolean apply(DistanceNode node) {
            if (node.distanceTable == null) {
                node.distanceTable = resetIfNotNull;
            }
            return true;
        }
    }

    static class AddSub implements Predicate<DistanceNode> {
        private final String desiredSub;
        private final String supportedSub;
        private final Reset r;

        AddSub(String desiredSub, String supportedSub, DistanceTable newSubsubtable) {
            this.r = new Reset(newSubsubtable);
            this.desiredSub = desiredSub;
            this.supportedSub = supportedSub;
        }
        @Override
        public boolean apply(DistanceNode node) {
            if (node == null) {
                throw new IllegalArgumentException("bad structure");
            } else {
                node.addSubtables(desiredSub, supportedSub, r);
            }
            return true;
        }
    }

    private static class LocaleDistance {
        private DistanceTable languageDesired2Supported = new DistanceTable();
        private int threshold = 40;

        public void add(List<String> desired, List<String> supported, int percentage) {
            int size = desired.size();
            if (size != supported.size() || size < 1 || size > 3) {
                throw new IllegalArgumentException();
            }
            final String desiredLang = desired.get(0);
            final String supportedLang = supported.get(0);
            if (size == 1) {
                languageDesired2Supported.addSubtable(desiredLang, supportedLang, percentage, false);
            } else {
                final String desiredScript = desired.get(1);
                final String supportedScript = supported.get(1);
                if (size == 2) {
                    languageDesired2Supported.addSubtables(desiredLang, supportedLang, desiredScript, supportedScript, percentage);
                } else {
                    final String desiredRegion = desired.get(2);
                    final String supportedRegion = supported.get(2);
                    languageDesired2Supported.addSubtables(desiredLang, supportedLang, desiredScript, supportedScript, desiredRegion, supportedRegion, percentage);
                }
            }
        }

        double distance(ULocale desired, ULocale supported) {
            Output<DistanceNode> table = new Output<>();
            String desiredLang = desired.getLanguage();
            String supportedlang = supported.getLanguage();
            int distance = languageDesired2Supported.getDistance(desiredLang, supportedlang, table);
            if (distance > threshold) {
                return 666;
            }

            String desiredScript = desired.getScript();
            String supportedScript = supported.getScript();
            distance += table.value.distanceTable.getDistance(desiredScript, supportedScript, table);
            if (distance > threshold) {
                return 666;
            }

            String desiredRegion = desired.getCountry();
            String supportedRegion = supported.getCountry();
            distance += table.value.distanceTable.getDistance(desiredRegion, supportedRegion, table);
            return distance;
        }

        @Override
        public String toString() {
            return languageDesired2Supported.toString();
        }
    }

    public double distance(ULocale desired, ULocale supported) {
        return langDistance.distance(desired, supported);
    }

    @Override
    public String toString() {
        return langDistance.toString();
    }

    private XLocaleMatcher(LocaleDistance langDistance) {
        this.langDistance = langDistance;
    }

    public static XLocaleMatcher getInstance() {
        Splitter bar = Splitter.on('_');
        SupplementalDataInfo sdi = CLDRConfig.getInstance().getSupplementalDataInfo();
        LocaleDistance langDistance = new LocaleDistance();
        int last = -1;
        for (String s : sdi.getLanguageMatcherKeys()) {
            /*
            <languageMatch desired="hy" supported="ru" percent="90" oneway="true"/>

            written  [am_*_*, en_*_GB, 90, true]
            written [ay, es, 90, true]
            written [az, ru, 90, true]
            written [az_Latn, ru_Cyrl, 90, true]
             */
            List<Row.R3<List<String>, List<String>, Integer>>[] sorted = new ArrayList[3];
            sorted[0] = new ArrayList<>();
            sorted[1] = new ArrayList<>();
            sorted[2] = new ArrayList<>();

            for (R4<String, String, Integer, Boolean> info : sdi.getLanguageMatcherData(s)) {
                List<String> desired = bar.splitToList(info.get0());
                List<String> supported = bar.splitToList(info.get1());
                final int distance = 100-info.get2();
                int size = desired.size();
                sorted[size-1].add(Row.of(desired, supported, distance));
                if (info.get3() != Boolean.TRUE && !desired.equals(supported)) {
                    sorted[size-1].add(Row.of(supported, desired, distance));
                }
            }
            for (List<Row.R3<List<String>, List<String>, Integer>> item1 : sorted) {
                int debug = 0;
                for (Row.R3<List<String>, List<String>, Integer> item2 : item1) {
                    langDistance.add(item2.get0(), item2.get1(), item2.get2());
                    System.out.println(s + "\t" + item2);
                }
                System.out.println(langDistance);
            }
        }
        return new XLocaleMatcher(langDistance);
    }


    public static void main(String[] args) {
        XLocaleMatcher localeMatcher = XLocaleMatcher.getInstance();
        System.out.println(localeMatcher.toString());

        String lastRaw = "no";
        String[] testsRaw = {"no_DE", "nb", "no", "no", "da", "zh_Hant", "zh_Hans", "en", "en_GB", "en_Cyrl", "fr"};
        ULocale last = new ULocale(lastRaw);
        final int testCount = testsRaw.length;
        ULocale[] tests = new ULocale[testCount];
        int i = 0;
        for (String testRaw : testsRaw) {
            tests[i++] = new ULocale(testRaw);
        }

        LocaleMatcher oldLocaleMatcher = new LocaleMatcher("");

        long likelyTime = 0;
        long newTime = 0;
        long oldTime = 0;
        final int maxIterations = 10000;
        for (int iterations = maxIterations; iterations > 0; --iterations) {
            ULocale desired = last;
            int count=0;
            for (ULocale test : tests) {
                final ULocale supported = test;

                long temp = System.nanoTime();
                final ULocale desiredMax = ULocale.addLikelySubtags(desired);
                final ULocale supportedMax = ULocale.addLikelySubtags(supported);
                likelyTime += System.nanoTime()-temp;

                temp = System.nanoTime();
                double dist1 = localeMatcher.distance(desiredMax, supportedMax);
                double dist2 = localeMatcher.distance(supportedMax, desiredMax);
                newTime += System.nanoTime()-temp;

                temp = System.nanoTime();
                double distOld1 = oldLocaleMatcher.match(desired, desiredMax, supported, supportedMax);
                double distOld2 = oldLocaleMatcher.match(supported, supportedMax, desired, desiredMax);
                oldTime += System.nanoTime()-temp;

                if (iterations == 1) {
                    System.out.println(desired + (dist1 != dist2 ? "\t => \t" : "\t <=> \t") + test
                        + "\t = \t" + dist1 
                        + "; \t" + 100*(1-distOld1)
                        );
                    if (dist1 != dist2) {
                        System.out.println(supported + "\t => \t" + desired
                            + "\t = \t" + dist2 
                            + "; \t" + 100*(1-distOld2));
                    }
                }

                desired = supported;
            }
        }
        System.out.println("likelyTime: " + likelyTime/maxIterations);
        System.out.println("newTime: " + newTime/maxIterations);
        System.out.println("oldTime: " + oldTime/maxIterations);
    }
}
